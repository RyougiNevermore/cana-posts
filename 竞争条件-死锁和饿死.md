---
title: '竞争条件: 死锁和饿死'
date: 2017-07-24 03:53:27
description:
featured_image:
issue: https://github.com/RyougiNevermore/ryouginevermore.github.io/issues/10
tags:
 - 锁
 - 程序设计
 - 简述
---

当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。

死锁是同步的，饥饿时异步的。

死锁可以认为是两个线程或进程同时在请求对方占有的资源，饥饿可以认为是一个线程或是进程在无限的等待另外两个或多个线程或进程占有的但是不会往外释放的资源出现以下四种情况会产生死锁：

- 相互排斥。一个线程或进程永远占有共享资源，比如，独占该资源。
- 循环等待。例如，进程A在等待进程B，进程B在等待进程C，而进程C又在等待进程A。
- 部分分配。资源被部分分配，例如，进程A和B都需要访问一个文件，同时需要用到打印机，进程A得到了这个文件资源，进程B得到了打印机资源，但两个进程都不能获得全部的资源了。
- 缺少优先权。一个进程获得了该资源但是一直不释放该资源，即使该进程处于阻塞状态。

按照前面的分析，情况1和情况4是线程或进程无休止的等待另外的几个线程或进程所占据的资源。针对上面可能出现死锁的几种情况，可以给出预防措施，比如控制线程或进程如果判断不能够获取到

饿死（starvation） 是一个线程长时间得不到需要的资源而不能执行的现象。 有人饿死并不代表着出现了死锁。

很有可能系统还能很好的进行。

所以，没有出现死锁并不能就认为系统是完好的。还要保证没有出现饿死的现象。

避免饿死就应该是采用队列的方式，保证每个人都有机会获得请求的资源。 当然实现方式可以很多个变化，比如优先级，时间片，等，都是“队列”的特殊形式。