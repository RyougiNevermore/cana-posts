---
title: 微服务应该是事件驱动： 自洽 vs 当局
date: 2017-07-10 03:42:32
description:
featured_image:
issue: https://github.com/RyougiNevermore/ryouginevermore.github.io/issues/4
tags:
 - 微服务
 - EDA
 - 隔离
 - 简述
---

## 前言

在一系列的假设与实践中去何构建 microservices 使用事件驱动的方法，得出事件驱动唯一真正的方式打造 microservices或任何复杂分布式体系结构。

## 事件驱动与解耦

事件驱动可以解决服务解耦，以及服务隔离。
微服务间光靠请求访问是不科学，某种意义上说，它们并没有解耦隔离，最终还是耦合在数据库上，从而导致数据库的集群会越来越庞大，很难就就。
一次请求，先访问服务a，然后需要访问服务b，那这次请求边界则是服务a加上服务b，意味着这两个服务可以视为一个服务。同时，额外的同步的请求会带来更多的隐患。这就是当局。服务a在这个环境里是要依赖其他服务的状态，且是同步的。

基于上述的场景，即，服务a需要服务b的数据，那么，如果基于事件，服务a去订阅服务b的事件，而事件是不可修改的，结果必然数据一致。
再看数据库，此时的数据库服务出现了两个，其相互独立，那么就意味着数据库有两个master，那么写的性能就有提升的可能，更下的数据库集群也更易维护。
当然，现在这种情况是，通过事件去解耦，那么事件服务，即消息队列需要有可靠性。
按照传统的方法，不难的会出现，消息队列服务集群会变成一个难点。
可是已经是事件驱动了，为何不使用event-sourcing呢，有了event-sourcing之后，那么消息队列的集群就好办多了，不用考虑一致性，此时，比如gnatsd就可以用了，这也是gnatsd的设计初衷。
此时，每个微服务是自洽的，在环境中，它不依赖其他微服务。

## 补充

当我们谈论我们谈论使用 microservices 作为车建设业务敏捷的 microservices 它系统： 系统允许商业更快地改变，生成新的功能，实验，并领先于其干扰素和竞争 （创业等）。
作为提供业务敏捷性而彼此交互的自治系统的一部分，我们也需要考虑会发生什么当这些系统部件的失败以及如何系统反应来克服失败。
中央先决条件是能够建立敏捷，故障容错系统是自治。
自治系统可以从彼此独立演化，因为它们往往摆脱依赖其他系统、 团队和流程。
更改服务 A 不应该强制系统 B 若要更改和任何其他的涟漪效应。
如果服务 A，B 类服务所依赖的下山，B 类服务应该不只是炸毁。

当然，硬要说，每个微服务都来个负载均衡，多副本，那就那样吧。